package com.tm.orm.validator;

import java.sql.*;
import java.util.*;
import java.lang.reflect.*;
import com.tm.orm.util.*;
import com.tm.orm.exception.*;

public class Validate {

	/**
	 * This map hold the records i.e., all the primary, foreign keys, and unique keys,
	 * present in the table. -> Record class
	 * String -> Table Name
	 */

	private Map<String, Record> recordMap; 
	private static Validate instance;

	private Validate(Map<String, Table> tableMap) {
		this.recordMap = new HashMap<>();
		try {

			for(Map.Entry<String, Table> entry : tableMap.entrySet()) {
				String tableName = entry.getKey();
				Table table = entry.getValue();

				Record record = new Record();

				record.setTableName(tableName);
				record.setPrimaryKeys(fetchPrimaryKeys(table));
				record.setForeignKeys(fetchForeignKeys(table));
				record.setUniqueKeys(fetchUniqueKeys(table));

				recordMap.put(tableName, record);

			}

		} catch(Exception exception) {
			exception.printStackTrace();	 
		}
		
	} 

	public static Validate getInstance(Map<String, Table> tableMap) {
		if(instance == null)
			instance = new Validate(tableMap);

		return instance;
	}

	public void forInsertion( final Object object, 
							  final Table table, 
							  final Map<String, Field> map
							) throws ORMException {

		Field field;
		String attrName;
		Attribute attribute;
		Object value;

		/**
		 *
		 * Note: This map contains no records of auto increment 
		 *		 fields. It only contains the fields that are needed
		 *	 	 to be written in prepared statement.
		 *
		 */


		try {	


			/**
			 * Validating primary keys
			 *
			 * If multipe primary keys are present (in case of composite keys), if any one primary autogenerated
			 * then there's no need to check for the uniqueness of the primary keys, it will always be unique.
			 * The nullability is of primary keys are checked by null validations. 
			 * Primary keys are need to be validated only when no of them is having autoincrement.
			 *
			 */

			 if(!table.hasAutoIncrementPrimaryKey()) {

			 	//Primary key needs to be validated for uniqueness
			 	String pvalue = "";
			 	for(String key : table.getPrimaryKeys()) {

			 	 	field = map.get(key);
			 	 	if(field == null) {
			 	 		throw new ORMException(key + " column not mapped to any field");
			 	 	}

			 	 	field.setAccessible(true);
			 	 	value = field.get(object);
			 	 	if(value == null)
			 	 	  	throw new ORMException(field.getName() + " field mapped to primary key is having null value.");

			 	 	 pvalue += value.toString(); 
			 	}
			 	
			 	if(recordMap.get(table.getName()).getPrimaryKeys().contains(pvalue))
			 		throw new ORMException("Primary key(s) already exist(s) for object " + object.toString());

			 	//As per design, if data passes the validation it must be inserterd
			 	//That's why we're updating our record even before insertion of data to database.

			 	recordMap.get(table.getName()).addPrimaryKey(pvalue);
			 }

			for(Map.Entry<String, Attribute> entry : table.getAttributes().entrySet()) {

				attribute = entry.getValue();
				attrName = entry.getKey();

				if(attribute.isAutoIncrement()) {
					
					/**
					 * This map doesn't contains fields which are auto incremented.
					 * More precisely this map only contains columns which are needed to
					 * be written in insert statement.
					 * 
					 */ 

						continue;
				}

				field = map.get(attribute.getName());

				if(field != null) {
					field.setAccessible(true);
					value = field.get(object);
				}
				else value = null;

				if(!attribute.isNullable()) {

					if(field == null) {

						// The user has not mapped this column and even though this column 
						// is not nullable.
						throw new ORMException("One or more non null columns of table: " + table.getName() + " has not been mapped");
					}

					if(value == null) {

						//The attribute is not nullable, but field's value is null.

						throw new ORMException("value of " + field.getName() + " is null, mapped to a not null column."); 
					}					

				} //Not null constrain has been validated.

				if(field == null || value == null) {
					//Null has to put because user has not mapped it.
					continue;
				}

				if(attribute.isForeignKey()) {

					if(!recordMap.get(table.getName()).getForeignKeyValues(attribute.getName()).contains(value.toString()))
						throw new ORMException("Foreign Key " + attrName + " has unmatched value " + value.toString() + " from it's reference table.");

					Record record = recordMap.get(table.getName());
					record.addForeignKey(attribute.getName(), value.toString());
				} //Foreign key contrain has been validated.


				if(attribute.isUniqueKey() && !attribute.isPrimaryKey()) {
					Set<String> tempSet = recordMap.get(table.getName()).getUniqueKeyValues(attribute.getName());
					if(tempSet.contains(value.toString()))
						throw new ORMException("For " + field.getName() + "'s value: " + value + " record already exists");
				Record record = recordMap.get(table.getName());
				record.addUniqueKey(attribute.getName(), value.toString());
				} //Unique constrain has been validated.

			}

		} catch(Exception exception) {
			throw new ORMException(exception.getMessage());
		}

	}


	private String getValue(String datatype, String name, ResultSet resultSet) {
 	  try {

 		 if(datatype.equalsIgnoreCase("INT"))
 			  return resultSet.getInt(name) + "";
 		 if(datatype.equalsIgnoreCase("CHAR"))
 		   	return resultSet.getString(name);
 		 if(datatype.equalsIgnoreCase("VARCHAR"))
 		   	return resultSet.getString(name);
 		 if(datatype.equalsIgnoreCase("DATE"))
 		   	return resultSet.getDate(name) + "";
 		 if(datatype.equalsIgnoreCase("SMALLINT UNSIGNED"))
 		   	return resultSet.getInt(name) + "";
 		 if(datatype.equalsIgnoreCase("TINYINT UNSIGNED"))
 		   	return resultSet.getInt(name) + "";
 		 if(datatype.equalsIgnoreCase("TIMESTAMP"))
 		   	return resultSet.getTime(name) + "";
 		 if(datatype.equalsIgnoreCase("FLOAT"))
 		   	return resultSet.getFloat(name) + "";
 		 if(datatype.equalsIgnoreCase("DECIMAL"))
 		   	return resultSet.getDouble(name) + "";
 		 if(datatype.equalsIgnoreCase("BIT"))
 		   	return resultSet.getInt(name) + "";

 	   }catch(Exception e) {
 	   	 	e.printStackTrace();
 	   }

 		return "";
 	}


 	private Set<String> fetchPrimaryKeys(Table table) throws ORMException {

 		Set<String> temp = new HashSet<>();

 		try {

 			String query = "SELECT ";
			String pvalue = "";
			for(String key : table.getPrimaryKeys())	query += (key + ",");
			query = query.substring(0, query.length() - 1);
			query += (" FROM " + table.getName());
	 		ResultSet set = ORMConnection.prepareStatement(query).executeQuery();	
	 		String tvalue;
			while(set.next()) {
				tvalue = "";
				for(String key : table.getPrimaryKeys()) {
				 	tvalue += table.getAttribute(key).getValue(set);
				}
				temp.add(tvalue);
			}

		} catch(Exception exception) {
			throw new ORMException("Couldn't load all the primary keys. " + exception.getMessage());
		}

		return temp;
 	}


 	private Map<String, Set<String>> fetchUniqueKeys(Table table) throws ORMException {

 		Map<String, Set<String>> map = new HashMap<>();
 		try {
 			List<String> uKeys = table.getUniqueKeys();
 			for(String key : uKeys) {
 				Set<String> temp = new HashSet<>();
 				Attribute attribute = table.getAttribute(key);
 				if(attribute.isPrimaryKey()) {
 					//Primary keys are validated differently, no need to validate them again
					//in the name of unique key.

					continue;
 				}

				PreparedStatement preparedStatement = ORMConnection.prepareStatement("SELECT " + attribute.getName() + " FROM " + table.getName());
				ResultSet resultSet = preparedStatement.executeQuery();

				while(resultSet.next()) {
					temp.add(attribute.getValue(resultSet) + "");
				}

				map.put(key, temp);

 			}

 		} catch(Exception exception) {
 			throw new ORMException("Couldn't load all the unique keys. " + exception.getMessage());
 		}

 		return map;
 	}

 	private Map<String, Set<String>> fetchForeignKeys(Table table) throws ORMException{
 		Map<String, Set<String>> map = new HashMap<>();
 		try {
 			List<ForeignKey> fKeys = table.getForeignKeys();
 			for(ForeignKey key : fKeys) {
 				Set<String> temp = new HashSet<>();
 				Attribute attribute = table.getAttribute(key.getName());
 				PreparedStatement preparedStatement = ORMConnection.prepareStatement("SELECT " + attribute.getForeignKeyRefCol() + " FROM " + attribute.getForeignKeyRefTable());
				ResultSet resultSet =  preparedStatement.executeQuery();
				while(resultSet.next())
					temp.add(getValue(attribute.getDatatype(), attribute.getForeignKeyRefCol(), resultSet));

				map.put(key.getName(), temp);
 			}

 		} catch(Exception exception) {
 			throw new ORMException("Couldn't load all the foreign keys. " + exception.getMessage());
 		}

 		return map;
 	}
}